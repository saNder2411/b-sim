{"version":3,"sources":["taoensso/timbre/appenders/core.cljc"],"mappings":"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","names":["var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","taoensso.timbre.appenders.core/println-appender","p__37245","vec__37246","cljs.core.nth","seq37244","self__5755__auto__","cljs.core/seq","_opts","data","map__37249","cljs.core/--destructure-map","cljs.core.get","output_","cljs.core.println","cljs.core/force","taoensso.timbre.appenders.core/console-appender","p__37251","vec__37252","map__37255","seq37250","raw-console?","js/console","level->logger","level","or__5045__auto__","G__37256","cljs.core/Keyword","js/Error","js/console.trace","js/console.debug","js/console.info","js/console.warn","js/console.error","js/console.log","temp__5804__auto__","logger","temp__5802__auto__","?meta","cljs.core/contains?","output","G__37259","fexpr__37258","cljs.core.assoc","args","vargs","err","cljs.core/cons","cljs.core.into_array","taoensso.timbre.appenders.core/console-?appender"],"sourcesContent":["(ns taoensso.timbre.appenders.core\n  \"Core Timbre appenders without any special dependency requirements.\n  These can be aliased into the main Timbre ns for convenience.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n  (:require\n   [clojure.string  :as str]\n   #?(:clj [clojure.java.io :as jio])\n   [taoensso.encore :as enc :refer [have have?]]))\n\n;; TODO Add a simple official rolling spit appender?\n\n;;;; Println appender (clj & cljs)\n\n#?(:clj (enc/declare-remote taoensso.timbre/default-out\n                            taoensso.timbre/default-err))\n\n#?(:clj (alias 'timbre 'taoensso.timbre))\n\n#?(:clj\n   (let [system-newline enc/system-newline]\n     (defn- atomic-println [x] (print (str x system-newline)) (flush))))\n\n(defn println-appender\n  \"Returns a simple `println` appender for Clojure/Script.\n  Use with ClojureScript requires that `cljs.core/*print-fn*` be set.\n\n  :stream (clj only) - e/o #{:auto :*out* :*err* :std-err :std-out <io-stream>}.\"\n\n  ;; Unfortunately no easy way to check if *print-fn* is set. Metadata on the\n  ;; default throwing fn would be nice...\n\n  [& #?(:clj [{:keys [stream] :or {stream :auto}}] :cljs [_opts])]\n  (let #?(:cljs []\n          :clj  [stream\n                 (case stream\n                   :std-err timbre/default-err\n                   :std-out timbre/default-out\n                   stream)])\n\n    {:enabled? true\n     :fn\n     (fn [data]\n       (let [{:keys [output_]} data]\n         #?(:cljs (println (force output_))\n            :clj\n            (let [stream\n                  (case stream\n                    :auto  (if (:error-level? data) *err* *out*)\n                    :*out* *out*\n                    :*err* *err*\n                    stream)]\n\n              (binding [*out* stream]\n                (atomic-println (force output_)))))))}))\n\n(comment (println-appender))\n\n;;;; Spit appender (clj only)\n\n#?(:clj\n   (defn- write-to-file [data fname append? output self]\n     (try\n       (with-open [^java.io.BufferedWriter w (jio/writer fname :append append?)]\n         (.write   w ^String output)\n         (.newLine w))\n\n       (catch java.io.IOException e\n         (if (:spit-appender/retry? data)\n           (throw e) ; Unexpected error\n           (do\n             (jio/make-parents fname)\n             (self (assoc data :spit-appender/retry? true))))))))\n\n#?(:clj\n   (defn spit-appender\n     \"Returns a simple `spit` file appender for Clojure.\"\n     [& [{:keys [fname append? locking?]\n          :or   {fname \"./timbre-spit.log\"\n                 append?  true\n                 locking? true}}]]\n\n     (have? enc/nblank-str? fname)\n\n     {:enabled? true\n      :fn\n      (let [lock (Object.)]\n        (fn self [{:keys [output_] :as data}]\n          (let [output (force output_)] ; Must deref outside lock, Ref. #330\n            (if locking? ; For thread safety, Ref. #251\n              (locking lock (write-to-file data fname append? output self))\n              (do           (write-to-file data fname append? output self))))))}))\n\n(comment\n  (spit-appender)\n  (let [f (:fn (spit-appender))]\n    (enc/qb 1e3 (f {:output_ \"boo\"}))))\n\n;;;; js/console appender (cljs only)\n\n#?(:cljs\n   (defn console-appender\n     \"Returns a simple js/console appender for ClojureScript.\n\n     Raw logging\n\n       There's 2 ways that Timbre can log to a web browser console:\n         1. As a prepared output string (default)\n         2. As a list of raw argument objects\n\n       The benefit of #2 is that it allows the browser to offer type-specific\n       object printing and inspection (e.g. for maps, etc.).\n\n       Raw logging can be enabled or disabled as follows:\n\n         1. On a per-call basis via a special 1st argument to your logging call:\n              (info ^:meta {:raw-console? true} arg1 ...)\n\n         2. Via middleware, by adding an option to your log data:\n              (fn my-middleware [data] (assoc data :raw-console? true))\n\n         3. Via an option provided to this appender constructor:\n              (console-appender {:raw-console? <bool>})\n\n     Ignoring library / \\\"blackbox\\\" code for accurate line numbers, etc.\n\n       Most web browsers offer a feature to ignore library or \\\"blackbox\\\" code\n       in their debugger.\n\n       You'll probably want to ignore at least the following:\n         `/taoensso/timbre/appenders/core\\\\.js$` ; Timbre console appender\n         `/taoensso/timbre\\\\.js$`                ; Timbre core\n         `/cljs/core\\\\.js$`                      ; ClojureScript core\n\n       Depending on the browser, you can usually set up these exclusions through\n       right-click popups and/or through a configurable list in a settings menu.\n\n       For example:\n         https://developer.chrome.com/docs/devtools/settings/ignore-list/\n         https://webkit.org/web-inspector/web-inspector-settings/\n         https://firefox-source-docs.mozilla.org/devtools-user/debugger/how_to/ignoring_sources/index.html\n         etc.\"\n\n     ;; TODO [#132] Any way of using something like `Function.prototype.bind`\n     ;; (Ref. https://goo.gl/IZzkQB) to get accurate line numbers in all\n     ;; browsers w/o the need for blackboxing?\n\n     [& [{:keys [raw-console?]}]]\n     {:enabled? true\n      :fn\n      (if-not (exists? js/console)\n        (fn [data] nil)\n\n        (let [;; Don't cache this; some libs dynamically replace js/console\n              level->logger\n              (fn [level]\n                (or\n                  (case level\n                    :trace  js/console.trace\n                    :debug  js/console.debug\n                    :info   js/console.info\n                    :warn   js/console.warn\n                    :error  js/console.error\n                    :fatal  js/console.error\n                    :report js/console.info)\n                  js/console.log))]\n\n          (fn [data]\n            (when-let [logger (level->logger (:level data))]\n\n              (if-let [raw-console?\n                       (enc/cond\n                         :let [?meta (get data :?meta)]\n\n                         ;; Useful for control via individual calls\n                         (contains? ?meta :raw-console?) (get ?meta :raw-console?)\n\n                         ;; Useful for control via middleware, etc.\n                         (contains? data  :raw-console?) (get data  :raw-console?)\n\n                         ;; Appender-level default\n                         :else raw-console?)]\n\n                (let [output\n                      ((:output-fn data)\n                       (assoc data\n                         :msg_  \"\"\n                         :?err nil))\n\n                      args ; (<output> ?<raw-error> <raw-arg1> <raw-arg2> ...)\n                      (let [vargs (:vargs data)]\n                        (if-let [err (:?err data)]\n                          (cons output (cons err vargs))\n                          (cons output           vargs)))]\n\n                  (.apply logger js/console (into-array args)))\n                (.call    logger js/console (force (:output_ data))))))))}))\n\n(comment (console-appender))\n\n;;;; Deprecated\n\n(enc/deprecated\n  #?(:cljs (def ^:deprecated console-?appender \"DEPRECATED\" console-appender)))\n"]}