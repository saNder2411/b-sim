{"version":3,"sources":["taoensso/truss/impl.cljc"],"mappings":"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","names":["taoensso.truss.impl/rsome","pred","coll","cljs.core.reduce","acc","in","temp__5804__auto__","p","cljs.core/reduced","taoensso.truss.impl/revery?","taoensso.truss.impl/revery","taoensso.truss.impl/some?","x","taoensso.truss.impl/ensure-set","cljs.core/set?","cljs.core/set","ensure-set","taoensso.truss.impl/ks=","ks","m","cljs.core._EQ_","cljs.core/keys","taoensso.truss.impl/ks<=","clojure.set/subset?","taoensso.truss.impl/ks>=","clojure.set/superset?","taoensso.truss.impl/ks-nnil?","p1__31693#","cljs.core.get","taoensso.truss.impl/default-error-fn","data_","cljs.core/deref","data","cljs.core.ex_info","cljs.core.dissoc","taoensso.truss.impl/*data*","taoensso.truss.impl/*error-fn*","taoensso.truss.impl/safe","e31696","js/Error","_","taoensso.truss.impl/safe?","env","or__5045__auto__","cljs.core/Keyword","cljs.core/map?","cljs.core/Symbol","temp__5802__auto__","v","cljs.analyzer.resolve_var","cljs.core/contains?","cljs.core/nil?","cljs.core/string?","cljs.core/integer?","cljs.core/number?","cljs.core/symbol?","cljs.core/keyword?","cljs.core/float?","cljs.core/vector?","cljs.core/coll?","cljs.core/list?","cljs.core/ifn?","cljs.core/fn?","cljs.core/associative?","cljs.core/sequential?","cljs.core/delay?","cljs.core/sorted?","cljs.core/counted?","cljs.core/reversible?","cljs.core/true?","cljs.core/false?","cljs.core/identity","cljs.core/not","cljs.core/boolean","taoensso.truss.impl/error-message","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","taoensso.truss.impl/WrappedError","taoensso.truss.impl/->WrappedError","val","taoensso.truss.impl/-assertion-error","msg","taoensso.truss.impl/-dummy-error","taoensso.truss.impl/-invar-violation!","elidable?","ns-sym","?line","?column","?file","arg-form","arg","?err","?data-fn","error-fn","G__31727","cljs.core/Delay","instant","js/Date","undefn-arg?","arg-val","arg-type","cljs.core/type","msg_","cljs.core/List","err","err-msg","?data","dynamic","data-fn","e31731","e","loc","cljs.core.assoc","output","cljs.core/*assert*"],"sourcesContent":["(ns ^:no-doc taoensso.truss.impl\n  \"Private implementation details.\"\n  (:refer-clojure :exclude [some?])\n  (:require\n   [clojure.set :as set]\n   #?(:clj  [clojure.java.io :as io])\n   #?(:cljs [cljs.analyzer]))\n  #?(:cljs (:require-macros [taoensso.truss.impl :refer [catching]])))\n\n(comment (require '[taoensso.encore :as enc]))\n\n;;;; TODO\n;; - Namespaced kw registry like clojure.spec, (truss/def <kw> <pred>)?\n;; - Ideas for easier sharing of composed preds?\n\n;;;; Manual Encore imports\n;; A bit of a nuisance but:\n;;   - Allows Encore to depend on Truss (esp. nb for back-compatibility wrappers).\n;;   - Allows Truss to be entirely dependency free.\n\n#?(:clj (defmacro if-cljs [then else] (if (:ns &env) then else)))\n#?(:clj\n   (defmacro catching\n     \"Cross-platform try/catch/finally.\"\n     ;; Very unfortunate that CLJ-1293 has not yet been addressed\n     ([try-expr                     ] `(catching ~try-expr ~'_ nil))\n     ([try-expr error-sym catch-expr]\n      `(if-cljs\n         (try ~try-expr (catch js/Error  ~error-sym ~catch-expr))\n         (try ~try-expr (catch Throwable ~error-sym ~catch-expr))))\n     ([try-expr error-sym catch-expr finally-expr]\n      `(if-cljs\n         (try ~try-expr (catch js/Error  ~error-sym ~catch-expr) (finally ~finally-expr))\n         (try ~try-expr (catch Throwable ~error-sym ~catch-expr) (finally ~finally-expr))))))\n\n(defn rsome   [pred coll]       (reduce (fn [acc in] (when-let [p (pred in)] (reduced p))) nil coll))\n(defn revery? [pred coll]       (reduce (fn [acc in] (if (pred in) true (reduced nil))) true coll))\n(defn revery  [pred coll] (when (reduce (fn [acc in] (if (pred in) true (reduced nil))) true coll) coll))\n\n(comment (revery integer? [1 2 3]) (revery integer? nil))\n\n#?(:cljs (defn ^boolean some? [x] (if (nil? x) false true))\n   :clj\n   (defn some?\n     {:inline (fn [x] `(if (identical? ~x nil) false true))}\n     [x] (if (identical? x nil) false true)))\n\n(defn ensure-set [x] (if (set? x) x (set x)))\n(let [ensure-set ensure-set]\n  (defn #?(:clj ks=      :cljs ^boolean ks=)      [ks m] (=             (set (keys m)) (ensure-set ks)))\n  (defn #?(:clj ks<=     :cljs ^boolean ks<=)     [ks m] (set/subset?   (set (keys m)) (ensure-set ks)))\n  (defn #?(:clj ks>=     :cljs ^boolean ks>=)     [ks m] (set/superset? (set (keys m)) (ensure-set ks)))\n  (defn #?(:clj ks-nnil? :cljs ^boolean ks-nnil?) [ks m] (revery?     #(some? (get m %))           ks)))\n\n#?(:clj\n   (defn get-source [form env]\n     (let [{:keys [line column file]} (meta form)\n           file\n           (if-not (:ns env)\n             *file* ; Compiling clj\n             (or    ; Compiling cljs\n               (when-let [url (and file (try (io/resource file) (catch Throwable _ nil)))]\n                 (try (.getPath (io/file url)) (catch Throwable _ nil))\n                 (do            (str     url)))\n               file))]\n\n       {:ns     (str *ns*)\n        :line   line\n        :column column\n        :file\n        (when (string? file)\n          (when-not (contains? #{\"NO_SOURCE_PATH\" \"NO_SOURCE_FILE\" \"\"} file)\n            file))})))\n\n(comment (io/resource \"taoensso/truss.cljc\"))\n\n;;;; Truss\n\n(defn default-error-fn [data_]\n  (let [data @data_]\n    (throw (ex-info @(:msg_ data) (dissoc data :msg_)))))\n\n(def ^:dynamic *data* nil)\n(def ^:dynamic *error-fn* default-error-fn)\n\n(defn  safe [pred] (fn [x] (catching (pred x))))\n(defn- safe?\n   \"[Optimization] Returns true for common preds that are naturally non-throwing.\"\n   [env p]\n   (or\n     (keyword? p)\n     (map?     p)\n     (set?     p)\n     (let [p\n           (if (symbol? p)\n             (if-let [v #?(:clj  (resolve                       p)\n                           :cljs (cljs.analyzer/resolve-var env p))]\n               @v p)\n             p)]\n\n       (contains?\n         #{nil? #_some? string? integer? number? symbol? keyword? float?\n           set? vector? coll? list? ifn? fn? associative? sequential? delay?\n           sorted? counted? reversible? true? false? identity not boolean}\n         p))))\n\n(comment (safe? nil 'nil?))\n\n#?(:clj\n   (defn- xpred\n     \"Expands any special predicate forms and returns [<expanded-pred> <safe?>].\"\n     [env pred]\n     (if-not (vector? pred)\n       [pred (safe? env pred)]\n       (let [[type a1 a2 a3] pred]\n         (assert a1 \"Special predicate [<special-type> <arg>] form w/o <arg>\")\n         (case type\n           :set=             [`(fn [~'x] (=             (ensure-set ~'x) (ensure-set ~a1))) false]\n           :set<=            [`(fn [~'x] (set/subset?   (ensure-set ~'x) (ensure-set ~a1))) false]\n           :set>=            [`(fn [~'x] (set/superset? (ensure-set ~'x) (ensure-set ~a1))) false]\n           :ks=              [`(fn [~'x] (ks=      ~a1 ~'x)) false]\n           :ks<=             [`(fn [~'x] (ks<=     ~a1 ~'x)) false]\n           :ks>=             [`(fn [~'x] (ks>=     ~a1 ~'x)) false]\n           :ks-nnil?         [`(fn [~'x] (ks-nnil? ~a1 ~'x)) false]\n           (    :el     :in) [`(fn [~'x]      (contains? (ensure-set ~a1) ~'x))  false]\n           (:not-el :not-in) [`(fn [~'x] (not (contains? (ensure-set ~a1) ~'x))) false]\n\n           :n=               [`(fn [~'x] (=  (count ~'x) ~a1)) false]\n           :n>=              [`(fn [~'x] (>= (count ~'x) ~a1)) false]\n           :n<=              [`(fn [~'x] (<= (count ~'x) ~a1)) false]\n\n           :instance?        [`(fn [~'x] (instance?  ~a1 ~'x)) false]\n           :satisfies?       [`(fn [~'x] (satisfies? ~a1 ~'x)) false]\n\n           ;; Pred composition\n           (let [self (fn [?pred] (when ?pred (xpred env ?pred)))\n\n                 ;; Support recursive expansion:\n                 [[a1 sf-a1?] [a2 sf-a2?] [a3 sf-a3?]] [(self a1) (self a2) (self a3)]\n\n                 sf-a1    (when a1 (if sf-a1? a1 `(safe ~a1)))\n                 sf-a2    (when a2 (if sf-a2? a2 `(safe ~a2)))\n                 sf-a3    (when a3 (if sf-a3? a3 `(safe ~a3)))\n                 sf-comp? (cond a3 (and sf-a1? sf-a2? sf-a3?)\n                                a2 (and sf-a1? sf-a2?)\n                                a1      sf-a1?)]\n\n             (case type\n               :and ; all-of\n               (cond\n                 a3 [`(fn [~'x] (and (~a1 ~'x) (~a2 ~'x) (~a3 ~'x))) sf-comp?]\n                 a2 [`(fn [~'x] (and (~a1 ~'x) (~a2 ~'x)))           sf-comp?]\n                 a1 [a1                                                sf-a1?])\n\n               :or ; any-of\n               (cond\n                 a3 [`(fn [~'x] (or (~sf-a1 ~'x) (~sf-a2 ~'x) (~sf-a3 ~'x))) true]\n                 a2 [`(fn [~'x] (or (~sf-a1 ~'x) (~sf-a2 ~'x)))              true]\n                 a1 [a1                                                    sf-a1?])\n\n               :not ; complement/none-of\n               ;; Note that it's a little ambiguous whether we'd want\n               ;; safe (non-throwing) behaviour here or not so choosing\n               ;; to interpret throws as undefined to minimize surprise\n               (cond\n                 a3 [`(fn [~'x] (not (or (~a1 ~'x) (~a2 ~'x) (~a3 ~'x)))) sf-comp?]\n                 a2 [`(fn [~'x] (not (or (~a1 ~'x) (~a2 ~'x))))           sf-comp?]\n                 a1 [`(fn [~'x] (not     (~a1 ~'x)))                        sf-a1?]))))))))\n\n(comment\n  (xpred nil string?)\n  (xpred nil [:or string? integer? :foo]) ; t\n  (xpred nil [:or string? integer? seq])  ; f\n  (xpred nil [:or string? integer? [:and number? integer?]]) ; t\n  (xpred nil [:or string? integer? [:and number? pos?]])     ; f\n  )\n\n;; #?(:clj\n;;    (defn- fast-pr-str\n;;      \"Combination `with-out-str`, `pr`. Ignores *print-dup*.\"\n;;      [x]\n;;      (let [w (java.io.StringWriter.)]\n;;        (print-method x w)\n;;        (.toString      w))))\n\n;; (comment (enc/qb 1e5 (pr-str {:a :A}) (fast-pr-str {:a :A})))\n\n(defn- error-message\n  ;; Temporary, to support Clojure 1.9\n  ;; Clojure 1.10+ now has `ex-message`\n  [x]\n  #?(:clj  (when (instance? Throwable x) (.getMessage ^Throwable x))\n     :cljs (when (instance? js/Error  x) (.-message              x))))\n\n(deftype WrappedError [val])\n(defn -assertion-error [msg] #?(:clj (AssertionError. msg) :cljs (js/Error. msg)))\n(def  -dummy-error #?(:clj (Object.) :cljs (js-obj)))\n(defn -invar-violation!\n  [elidable? ns-sym ?line ?column ?file pred arg-form arg ?err ?data-fn]\n  (when-let [error-fn *error-fn*]\n    (error-fn ; Nb consumer must deref while bindings are still active\n     (delay\n      (let [instant     #?(:clj (java.util.Date.) :cljs (js/Date.))\n            undefn-arg? (instance? WrappedError arg)\n            arg-val     (if undefn-arg? 'truss/undefined-arg       arg)\n            arg-type    (if undefn-arg? 'truss/undefined-arg (type arg))\n\n            ;; arg-str\n            ;; (cond\n            ;;   undefn-arg? \"<truss/undefined-arg>\"\n            ;;   (nil? arg)  \"<truss/nil>\"\n            ;;   :else\n            ;;   (binding [*print-readably* false\n            ;;             *print-length*   3]\n            ;;     #?(:clj  (fast-pr-str arg)\n            ;;        :cljs (pr-str      arg))))\n\n            ?err\n            (cond\n              (identical? -dummy-error ?err) nil\n              (instance?  WrappedError ?err)\n              (.-val     ^WrappedError ?err)\n              :else                    ?err)\n\n            msg_\n            (delay\n              (let [msg\n                    (str \"Invariant failed at \" ns-sym\n                      (when ?line (str \"|\" ?line #_(when ?column (str \".\" ?column)))) \": \"\n                      (list pred #_arg-form arg-val))]\n\n                (if-let [err ?err]\n                  (let [err-msg #_(ex-message err) (error-message err)]\n                    (if undefn-arg?\n                      (str msg \"\\r\\n\\r\\nError evaluating arg: \"  err-msg)\n                      (str msg \"\\r\\n\\r\\nError evaluating pred: \" err-msg)))\n                  msg)))\n\n            ?data\n            (let [dynamic *data*\n                  arg\n                  (when-let [data-fn ?data-fn]\n                    (catching (data-fn) e\n                      {:truss/error e}))]\n\n              (when (or   dynamic      arg)\n                {:dynamic dynamic :arg arg}))\n\n            loc {:ns ns-sym}\n            loc (if-let [v ?line]   (assoc loc :line   v) loc)\n            loc (if-let [v ?column] (assoc loc :column v) loc)\n            loc (if-let [v ?file]   (assoc loc :file   v) loc)\n\n            output\n            {:msg_ msg_\n             :dt   instant\n             :pred pred\n             :loc  loc\n             :arg  {:form      arg-form\n                    :value     arg-val\n                    :type      arg-type}\n             :env  {:elidable? elidable?\n                    :*assert*  *assert*}}\n\n            output (if-let [v ?data] (assoc output :data v) output)\n            output (if-let [v ?err]  (assoc output :err  v) output)]\n\n        output)))))\n\n#?(:clj\n   (defn const-form? \"See issue #12\" [x]\n     (not (or (list? x) (instance? clojure.lang.Cons x)))))\n\n#?(:clj\n   (defmacro -invar\n     \"Written to maximize performance + minimize post Closure+gzip Cljs code size.\"\n     [elidable? truthy? source pred x ?data-fn]\n     (let [const-x? (const-form? x) ; Common case\n           [pred* safe-pred?] (xpred #?(:clj nil :cljs &env) pred)\n           {:keys [ns line column file]} source\n           ns-sym (symbol ns)]\n\n       (if const-x? ; Common case\n         (if safe-pred? ; Common case\n           `(if (~pred* ~x)\n              ~(if truthy? true x)\n              (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred '~x ~x nil ~?data-fn))\n\n           `(let [~'e (catching (if (~pred* ~x) nil -dummy-error) ~'e ~'e)]\n              (if (nil? ~'e)\n                ~(if truthy? true x)\n                (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred '~x ~x ~'e ~?data-fn))))\n\n         (if safe-pred?\n           `(let [~'z (catching ~x ~'e (WrappedError. ~'e))\n                  ~'e (if (instance? WrappedError ~'z)\n                        ~'z\n                        (if (~pred* ~'z) nil -dummy-error))]\n\n              (if (nil? ~'e)\n                ~(if truthy? true 'z)\n                (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred '~x ~'z ~'e ~?data-fn)))\n\n           `(let [~'z (catching ~x ~'e (WrappedError. ~'e))\n                  ~'e (catching\n                        (if (instance? WrappedError ~'z)\n                          ~'z\n                          (if (~pred* ~'z) nil -dummy-error)) ~'e ~'e)]\n\n              (if (nil? ~'e)\n                ~(if truthy? true 'z)\n                (-invar-violation! ~elidable? '~ns-sym ~line ~column ~file '~pred '~x ~'z ~'e ~?data-fn))))))))\n\n(comment\n  (macroexpand '(-invar true false 1      string?    \"foo\"             nil)) ; Type 0\n  (macroexpand '(-invar true false 1 [:or string?]   \"foo\"             nil)) ; Type 0\n  (macroexpand '(-invar true false 1    #(string? %) \"foo\"             nil)) ; Type 1\n  (macroexpand '(-invar true false 1      string?    (str \"foo\" \"bar\") nil)) ; Type 2\n  (macroexpand '(-invar true false 1    #(string? %) (str \"foo\" \"bar\") nil)) ; Type 3\n  (enc/qb 1e6\n    (string? \"foo\")                                          ; Baseline\n    (-invar true false 1   string?    \"foo\"             nil) ; Type 0\n    (-invar true false 1 #(string? %) \"foo\"             nil) ; Type 1\n    (-invar true false 1   string?    (str \"foo\" \"bar\") nil) ; Type 2\n    (-invar true false 1 #(string? %) (str \"foo\" \"bar\") nil) ; Type 3\n    (try\n      (string? (try \"foo\" (catch Throwable _ nil)))\n      (catch Throwable _ nil)))\n  ;; [41.86 50.43 59.56 171.12 151.2 42.0]\n\n  (-invar false false 1 integer? \"foo\"   nil) ; Pred failure example\n  (-invar false false 1 zero?    \"foo\"   nil) ; Pred error example\n  (-invar false false 1 zero?    (/ 5 0) nil) ; Form error example\n  )\n\n#?(:clj\n   (defmacro -invariant [elidable? truthy? source args]\n     (let [bang?      (= (first args) :!) ; For back compatibility, undocumented\n           elidable?  (and elidable? (not bang?))\n           elide?     (and elidable? (not *assert*))\n           args       (if bang? (next args) args)\n           in?        (= (second args) :in) ; (have pred :in xs1 xs2 ...)\n           args       (if in? (cons (first args) (nnext args)) args)\n\n           data?      (and (> (count args) 2) ; Distinguish from `:data` pred\n                           (= (last (butlast args)) :data))\n           ?data-fn   (when data? `(fn [] ~(last args)))\n           args       (if data? (butlast (butlast args)) args)\n\n           auto-pred? (= (count args) 1) ; Unique common case: (have ?x)\n           pred       (if auto-pred? 'taoensso.truss.impl/some? (first args))\n           [?x1 ?xs]  (if auto-pred?\n                        [(first args) nil]\n                        (if (nnext args) [nil (next args)] [(second args) nil]))\n           single-x?  (nil? ?xs)\n           in-fn\n           `(fn [~'__in] ; Will (necessarily) lose exact form\n              (-invar ~elidable? ~truthy? ~source ~pred ~'__in ~?data-fn))]\n\n       (if elide?\n         (if truthy?\n           true\n           (if single-x? ?x1 (vec ?xs)))\n\n         (if-not in?\n\n           (if single-x?\n             ;; (have pred x) -> x\n             `(-invar ~elidable? ~truthy? ~source ~pred ~?x1 ~?data-fn)\n\n             ;; (have pred x1 x2 ...) -> [x1 x2 ...]\n             (if truthy?\n               `(do ~@(mapv (fn [x] `(-invar ~elidable? ~truthy? ~source ~pred ~x ~?data-fn)) ?xs) true)\n               (do    (mapv (fn [x] `(-invar ~elidable? ~truthy? ~source ~pred ~x ~?data-fn)) ?xs))))\n\n           (if single-x?\n\n             ;; (have? pred :in xs) -> bool\n             ;; (have  pred :in xs) -> xs\n             (if truthy?\n               `(revery? ~in-fn ~?x1)\n               `(revery  ~in-fn ~?x1))\n\n             ;; (have? pred :in xs1 xs2 ...) -> [bool1 ...]\n             ;; (have  pred :in xs1 xs2 ...) -> [xs1   ...]\n             (if truthy?\n               `(do ~@(mapv (fn [xs] `(revery? ~in-fn ~xs)) ?xs) true)\n               (do    (mapv (fn [xs] `(revery  ~in-fn ~xs)) ?xs)))))))))\n"]}